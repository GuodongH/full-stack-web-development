# 技术选型

今天的技术领域真是让人眼花缭乱了，除了前端各种层出不穷的框架之外，后端的技术又冒出了容器、微服务等概念；数据库上除了传统的关系型数据库，各种 NoSQL 数据库纷纷登场，分布式数据库的需求也是越来越强；这还没算上巨火的大数据、人工智能等。这么多的概念，我们该怎么去选择，如何去学习？

但其实万变不离其宗，大家都认可是趋势的技术一般都会补充到现有技术中。比如注解本来是 .Net 平台先发展出来的，但由于这种方式确实可以减少大量的重复编码，而且更清晰易懂，所以逐渐的 Java 平台也引入了这个特性。再比如“约定优于配置” (Convention over configuration) 这个设计范式本来是 `Ruby on Rails` 提倡的，由于确实省却了以前大量的配置带来的麻烦，所以现如今的大多数框架，不管是前端还是后端，都吸收了这个理念。

本书中采用的技术选型原则是

1. 成熟的框架：成熟的框架可能不会采用最时髦的一些概念，但是成熟本身意味着经历了考验。在我们选择技术方向时，前瞻的一些领域当然要关注，但对于商用系统来说，系统的稳定性是必须放到很高的优先级考虑的。因为我们肯定不想系统在上线后发生一些意想不到的事情。
2. 活跃的社区：在一个开源技术成为主流的时代里，一个活跃的社区是考量这个项目是否有生命力的重要指标之一。活跃的社区意味着你可以很方便的找到一些常见问题的答案，而不是自己孤独的探索。活跃的社区还意味着更丰富的社区生态，社区会开发很多第三方的软件包来完善或补充现有框架中不太理想的地方，这在开发中可以极大的提升我们的开发效率，而不用重造轮子。
3. 工程化的支持：有一些小而美的框架在个人开发或者开发某个小功能的时候很好用，但是如果它缺乏了工程化的支持，就无法推广到大团队中。工程化这个概念说起来比较宽泛，比如模块化的支持、自动化测试的支持、编译自动化的支持等等。
4. 采用统一的编程思想：一个统一的编程思想或风格可以显著降低开发成本，比如函数编程风格在 Java 和 JavaScript 中都可以采用函数编程，这样的编程风格的统一会让团队协作起来更顺滑，也降低了团队人员调换的成本。如果团队能力强一些的话，可以在前端、后端、客户端（Android ， iOS）统一采用 Rx 的话，更是可以在多个平台和编程语言之上使用响应式编程作为交流的语言。
5. 快速开发的支持：如果框架中有一些诸如“约定优于配置” (Convention over configuration) 的特性的话，那么我们的开发会相对更方便更容易一些，如果框架支持注解的话，就更会让开发效率得到更大的提升。

## 前端框架选型

现在前端框架多到让开发者眼花缭乱，但主流的三大框架还是逐渐浮出水面： React 、 Angular 和 Vue 。从流行度来说 React 是目前全球最流行的前端框架、而 Vue 则是中国开发者最爱的前端框架。但我们本书中选用的是 Angular 6.x，为什么呢？有以下几个理由:

1. 无缝的 TypeScript 集成： TypeScript 在 React 和 Vue 也可以使用，甚至官方也有较强的支持，但是都没有 Angular 中使用 TypeScript 这种顺畅的感觉。这主要是因为在 Angular 中 TypeScript 是一类公民（first-class citizen），是官方作为开发的首选语言，这一点在 React 和 Vue 中是做不到的。但为什么 TypeScript 对于我们的技术选型这么重要呢？在大一点的公司里，基本都沉淀了很多面向对象的基础软件库、最佳实践以及大量的熟练掌握面向对象概念的程序员。 TypeScript 对于复用这些资源是非常必要的，而且如果使用原生的 JavaScript 开发大型项目，由于其缺乏强类型约束，在实际开发中往往出现难以调试的一些问题。可以这么说，对于有面向对象经验的开发者来说， TypeScript 有着近似于零的学习成本，而且对于代码质量的提升是非常巨大的。
2. 开发模型的良好体验： Angular 使用模块组织代码，基于组件进行开发，这个特性使得 Angular 开发在模式上非常接近于后端 Java 开发或者 Android 和 iOS 应用开发。
3. 对于响应式编程良好的支持： `rxjs` 框架的开发者 Ben Lesh 已经入职 Google ，入职前，其实 Angular 已经是前端框架中和 `rxjs` 配合度最好的了，后期 Angular 中的 `rxjs` 使用体验肯定越来越好。

## 后端框架选型

后端我们选择了 Spring Boot 2.x ，Spring 说起来已经有超过 15 年的开发时间了，从成熟度上来说都快熟透了 ;-) 。 Spring 也基本成为了 Java 开发中的事实标准，但是 Spring 一直在不断进化自身，吸收别的平台或框架上的最佳实践。

Spring Boot 就是一个让 Spring 这棵老树发新芽的框架，Spring Boot 以“开箱即用”为基本理念，提供一套可以快速开发 Spring 应用的框架。 Spring Boot 充分应用了注解、Java Config 等方式让我们摆脱传统 Spring 中的臃肿的 xml 配置文件，以相当简洁的方式专注于业务逻辑的开发。

Spring Boot 主要有以下特色

* 创建一个单独可运行的 Spring 应用，无需依赖外部的 Web 容器。
* 直接嵌入 Tomcat, Jetty 或者 Undertow ，无需发布 WAR 包
* 提供各种 'starter' 依赖用以简化编译配置
* 在可能的情况下，自动配置 Spring 和第三方类库
* 提供生产环境的监控指标、健康检查以及外部化的配置
* 无代码生成，零 XML 配置

## 数据库选型

### MongoDB

在今天这么多 SQL 和 NOSQL 数据库喷薄而出的时代里，选择成了一件很痛苦的事情。在 SQL 这个层面上我感觉倒是还好，因为 MySQL/MariaDB 基本一枝独秀 （MariaDB 是在 Oracle 接手 MySQL 后，基于 MySQL 开发的社区维护版本）。此外如果原来比较习惯 Oracle 的话，可以使用 PostgreSQL ，两者比较像，迁移成本较低。

NoSQL 方向上， MongoDB 作为最早得到大规模应用的文档型数据库是一个非常稳妥的选择，而且 MongoDB 还在不断在提供可以和 SQL 数据库对标的一些功能，类似表连接的功能和事务等特性。本书中采用的数据存储的主要方式是 MongoDB。

目前来看， MongoDB 具备以下特点

* 无 schema ，这一特性使得 MongoDB 非常适合快速开发，因为开发中表结构可能经常变化，在 SQL 中，表结构的变化带来的维护问题经常制约开发人员的响应速度。
* 单一对象结构非常清晰
* 没有复杂的连接 （ `join` )
* 可以进行深度嵌套对象的查询
* 支持使用类似 SQL 的查询语言
* 易于优化
* 易于拓展
* 无需转换或映射 Java 对象到数据库
* 更快的数据访问速度
* 快速添加 Replica Set ，提供高可用性
* Spring Data 提供无缝集成

### Elasticsearch

Elasticsearch 是基于 `Lucene` 开发的搜索引擎，它提供了一个分布式的、支持多租户的全文搜索引擎，提供 JSON 形式的文档存储。和 MongoDB 类似的是， Elasticsearch 也是一个文档型数据库，但 Elasticsearch 的主要目的是解决搜索问题，也就是说使用 Elasticsearch 更多的是使用其搜索特性，而不是其他的能力。

在本书中. 我们使用 Elasticsearch 作为模糊搜索和条件搜索功能。 Elasticsearch 一般是提供一整套的方案，包括数据集合、日志分析引擎（ `logtash` ）以及数据分析和可视化工具（ `kibana` ），这个全家桶一般叫做 "Elastic Stack" (你可能会经常看到 `ELK` 这个缩写，指的就是这个全家桶)。

Elasticsearch 的搜索能力强，不仅仅在于它可以支持搜索指定文档属性中的字符串类似的这种常见搜索功能，而且可以分析文档，检查是否搜索的关键字存在于整个文档，无论这个关键字是否中间有其他词的间隔；也会像 Google 那样评价所有结果的相关性；甚至包括更复杂的特性，比如同义词、多种拼写形式或者有一定拼写错误的容错率等等。

本书中采用 Elasticsearch 来为系统添加搜索功能，此外各个微服务系统的日志都会输出到 Elasticsearch 便于日志的统一管理和查询。

### Redis

和 MongoDB 与 Elasticsearch 不同，Redis 是一个基于键值对的 NoSQL 内存数据库。它既可以当作数据库、又可以当作缓存或者消息代理。它支持多种数据结构：字符串、哈希、列表、集合、排序集合，位图和地理位置索引等。 Redis 有内建的复制机制，支持 Lua 脚本， LRU 回收，事务以及不同程度的磁盘存储。

Redis 优势有：

* 性能极高 – Redis 能读的速度可以达到 110000 次/s ，写的速度可以达到 81000次/s 。
* 丰富的数据类型 – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
* 事务 – Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 `MULTI` 和 `EXEC` 指令包起来。
* 丰富的特性 – Redis 还支持发布/订阅, 通知, key 过期等等特性。

在本书中，我们采用 Redis 作为缓存机制，而不是作为一个数据库。
